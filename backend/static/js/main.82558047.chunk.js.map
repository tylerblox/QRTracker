{"version":3,"sources":["logo.svg","actions/index.js","components/ConfirmEventModal/ConfirmEventModal.jsx","App.js","serviceWorker.js","reducers/qrScannerReducer.js","reducers/index.js","index.js"],"names":["module","exports","resetScanner","dispatch","getState","type","getCookie","name","cookieValue","document","cookie","cookies","split","i","length","trim","substring","decodeURIComponent","scanCodeBegin","confirmCodeBegin","ConfirmEventModal","props","most_recent_code","qr_code_fetched","qr_code_fetch_error","confirmed_qr_code","showModal","className","error_with_confirmation","onClick","event","date","location","confirmQrCode","event_promoter","id","mapDispatchToProps","scanQrCode","url","fetch","process","then","res","ok","json","payload","value","catch","err","error","confirmed","method","mode","cache","credentials","headers","redirect","body","JSON","stringify","setScannerActive","active","qr_scanner","scanner_active","connect","React","useState","scanMode","state","setState","resultFromScanner","useEffect","console","log","delay","onError","onScan","data","loading","message","Boolean","window","hostname","match","initialState","fetching_qr_code","confirming_qr_code","rootReducer","combineReducers","action","store","createStore","applyMiddleware","thunk","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.82558047.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","export const QR_SCANNER_START = 'QR_SCANNER_START'\nexport const QR_SCANNER_SUCCESS = 'QR_SCANNER_SUCCESS'\nexport const QR_SCANNER_ERROR = 'QR_SCANNER_ERROR'\n\nexport const RESET = 'RESET'\nexport function resetScanner(){\n    return (dispatch, getState) => {\n        dispatch({\n            type: RESET,\n        })\n    }\n}\n\nfunction getCookie(name) {\n    var cookieValue = null;\n    if (document.cookie && document.cookie !== '') {\n        var cookies = document.cookie.split(';');\n        for (var i = 0; i < cookies.length; i++) {\n            var cookie = cookies[i].trim();\n            // Does this cookie string begin with the name we want?\n            if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                break;\n            }\n        }\n    }\n    return cookieValue;\n}\n\nconst scanCodeBegin = () => ({\n    type: QR_SCANNER_START\n})\nconst scanCodeSuccess = (value) => ({\n    type: QR_SCANNER_SUCCESS,\n    payload: {value}\n})\nconst scanCodeError = (error) => ({\n    type: QR_SCANNER_ERROR,\n    payload: {error}\n})\n\n\nexport function scanQrCode(url){\n    return (dispatch, getState) => {\n        dispatch(scanCodeBegin)\n        fetch(process.env.REACT_APP_SSL + '://' + url)\n        .then(res => {\n\n            if (!res.ok){\n                throw 'whoops'\n            }\n            \n            return res.json()\n        })\n        .then(\n            json => dispatch(scanCodeSuccess(json))\n        )\n        .catch(err => dispatch(scanCodeError(err)))\n    }\n}\n\n\nexport const CONFIRM_CODE_START = 'CONFIRM_CODE_START'\nexport const CONFIRM_CODE_SUCCESS = 'CONFIRM_CODE_SUCCESS'\nexport const CONFIRM_CODE_ERROR = 'CONFIRM_CODE_ERROR'\n\nconst confirmCodeBegin = () => ({\n    type: CONFIRM_CODE_START\n})\nconst confirmCodeSuccess = (value) => ({\n    type: CONFIRM_CODE_SUCCESS,\n    payload: {value}\n})\nconst confirmCodeError = (error) => ({\n    type: CONFIRM_CODE_ERROR,\n    payload: {error}\n})\n\nexport function confirmQrCode(confirmed, payload){\n    if (confirmed){\n        return (dispatch, getState) => {\n            dispatch(confirmCodeBegin)\n            fetch(\n                process.env.REACT_APP_HOST + '/api/event_register/',\n                {\n                    method: 'POST', // *GET, POST, PUT, DELETE, etc.\n                    mode: 'cors', // no-cors, *cors, same-origin\n                    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached\n                    credentials: 'same-origin', // include, *same-origin, omit\n                    headers: {\n                    'Content-Type': 'application/json',\n                    'X-CSRFToken': getCookie('csrftoken')\n                    },\n                    redirect: 'follow', // manual, *follow, error\n                    body: JSON.stringify(payload) // body data type must match \"Content-Type\" header\n                }\n            )\n            .then(res => {\n                if (!res.ok){\n                    throw 'whoops'\n                }\n                \n                return res.json()\n            })\n            .then(\n                json => dispatch(confirmCodeSuccess(json))\n            )\n            .catch(err => dispatch(confirmCodeError(err)))\n        }\n    } else {\n        return resetScanner()\n    }\n}\nexport const SET_SCANNER_ACTIVE = 'SET_SCANNER_ACTIVE'\n\nexport function setScannerActive(active=true){\n    return (dispatch, getState) => {\n        const most_recent_code = !active ? getState().qr_scanner.most_recent_code : null\n        dispatch({\n            type: SET_SCANNER_ACTIVE,\n            payload: {scanner_active: active, most_recent_code}\n        })\n    }\n}","import React from 'react'\n\nexport const ConfirmEventModal = (props) => {\n    const showModal = (props) => {\n        return props.most_recent_code\n        && props.qr_code_fetched &&\n        !props.qr_code_fetch_error \n        && !props.confirmed_qr_code\n    }\n    return showModal(props) ? (\n          <div className=\"confirm-event-modal\">\n            <div className=\"confirm-event-content\">\n                {props.error_with_confirmation && (<p>Error in confirming event.  Please try again, or <span onClick={props.resetScanner}>Scan a new Code</span></p>)}\n                <h1>Confirm this Event</h1>\n                <ul>\n                <li>\n                    {props.most_recent_code.event.name}\n                </li>\n                <li>\n                    {props.most_recent_code.event.date}\n                </li>\n                <li>\n                    {props.most_recent_code.event.location.name}\n                </li>\n                </ul>\n            </div>\n            <div className=\"confirmation-buttons\">\n                <button\n                className=\"button--primary\"\n                onClick={\n                    () => {\n                      props.confirmQrCode(true, {event_promoter: props.most_recent_code.id})\n                    }\n                }\n                >\n                Yes\n                </button>\n\n                <button\n                className=\"button--secondary\"\n                onClick={\n                    () => {\n                      props.confirmQrCode(false, {})\n                    }\n                }\n                >\n                No\n                </button>\n            </div>\n\n          </div>\n        ) : null\n        \n}","import React, { Component } from 'react';\nimport { connect } from 'react-redux'\nimport QrReader from 'react-qr-reader'\nimport {scanQrCode, confirmQrCode, setScannerActive, resetScanner} from './actions'\nimport logo from './logo.svg';\nimport './App.css';\nimport {ConfirmEventModal} from './components/ConfirmEventModal'\n\nfunction App(props) {\n  const [state, setState] = React.useState({\n    scanMode: true\n  })\n\n  const {most_recent_code:resultFromScanner} = props\n  React.useEffect(() => {\n    resultFromScanner && props.setScannerActive(false)\n  },[resultFromScanner])\n\n  const handleScan = data => {\n    if (data) {\n      props.scanQrCode(data)\n    }\n  }\n\n  console.log(props.most_recent_code)\n\n  const handleError = err => {\n    console.error(err)\n  }\n  const changeScanModeSetting = () => {\n    const {scanMode} = state\n    setState({...state, scanMode: !scanMode})\n  }\n \n  return (\n    <div className=\"App\">\n\n      <ConfirmEventModal \n        most_recent_code = {props.most_recent_code}\n        qr_code_fetched = {props.qr_code_fetched}\n        qr_code_fetch_error = {props.qr_code_fetch_error}\n        confirmed_qr_code = {props.confirmed_qr_code}\n        error_with_confirmation = { props.error_with_confirmation}\n        resetScanner = {props.resetScanner}\n        confirmQrCode = {props.confirmQrCode}\n      />\n\n      <button onClick={changeScanModeSetting}>\n        {state.scanMode ? 'Switch To Manual Input' : 'Switch to Scanner Mode'}\n      </button>\n      {\n        state.scanMode ? (\n          <>\n            <div className=\"qr-content\">\n              {\n                props.scanner_active && (\n                  <QrReader\n                    className=\"qr-scanner\"\n                    delay={1000}\n                    onError={handleError}\n                    onScan={handleScan}\n                  />\n                ) || <p> Begin Scanning Below...</p>\n              }\n              {\n                props.most_recent_code && props.confirmed_qr_code && (\n                  <h2 className=\"registration-success\">Successfully registered!</h2>\n                )\n              }\n              {props.loading && <p>Loading...</p>}\n            {props.qr_code_fetch_error && <p>There was an error scanning the QR code.. {props.qr_code_fetch_error.message}</p>}\n            </div>\n            <button\n              onClick={\n                () => {\n                  props.setScannerActive(!props.scanner_active)\n                }\n              }\n            >\n              {props.most_recent_code ? 'Scan Again' : props.scanner_active ? 'Stop Scanning' : 'Start Scanning'}\n            </button>\n          </>\n        ) : <p> manual entry mode todo: </p>\n      }\n    </div>\n  );\n}\n\nconst mapDispatchToProps = {\n  scanQrCode,\n  confirmQrCode,\n  setScannerActive,\n  resetScanner\n}\nconst mapStateToProps = ({qr_scanner}) => qr_scanner\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import {\n    QR_SCANNER_START,\n    QR_SCANNER_SUCCESS,\n    QR_SCANNER_ERROR,\n    CONFIRM_CODE_START,\n    CONFIRM_CODE_SUCCESS,\n    CONFIRM_CODE_ERROR,\n    SET_SCANNER_ACTIVE,\n    RESET\n} from '../actions'\n\nconst initialState = {\n    scanner_active: true,\n    fetching_qr_code: false,\n    qr_code_fetch_error: null,\n    most_recent_code: null,\n    qr_code_fetched: false,\n    confirming_qr_code: false,\n    error_with_confirmation: null,\n    confirmed_qr_code: false,\n}\n\n\nexport const qr_scanner = (state=initialState, action) => {\n    switch(action.type){\n        case RESET:\n            return {\n                ...state,\n                ...initialState\n            }\n        case SET_SCANNER_ACTIVE:\n            return {\n                ...state,\n                ...action.payload\n            }\n        case QR_SCANNER_START:\n            return {\n                ...state,\n                fetching_qr_code: true,\n                scanner_active: false,\n            }\n        case QR_SCANNER_SUCCESS:\n            return {\n                ...state,\n                ...initialState,\n                scanner_active: false,\n                qr_code_fetched: true,\n                fetching_qr_code: false,\n                most_recent_code: action.payload.value\n            }\n        case QR_SCANNER_ERROR:\n            return {\n                ...state,\n                scanner_active: false,\n                qr_code_fetched: false,\n                fetching_qr_code: false,\n                qr_code_fetch_error: action.payload.error\n            }\n        case CONFIRM_CODE_START:\n            return {\n                ...state,\n                confirming_qr_code: true\n            }\n        case CONFIRM_CODE_SUCCESS:\n            return {\n                ...state,\n                scanner_active: false,\n                confirmed_qr_code: true\n            }\n        case CONFIRM_CODE_ERROR:\n            return {\n                ...state,\n                error_with_confirmation: action.payload.error\n            }\n        default:\n            return state\n    }\n}\n","import { combineReducers } from 'redux'\nimport {qr_scanner} from './qrScannerReducer'\nconst rootReducer = combineReducers({\n    qr_scanner\n})\n\nexport default rootReducer","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { Provider } from 'react-redux'\nimport { createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk';\n\nimport rootReducer from './reducers'\n\nconst store = createStore(rootReducer, applyMiddleware(thunk))\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}